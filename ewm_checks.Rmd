---
title: "EWM checks"
author: "Balint SZEBENYI"
date: '2016 december 1 '
output: html_document
---



```{r knitr_setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r setup, include=FALSE}
PROJECT_DIR <- '/home/szebenyib/win7_link/projektek/2016_audi/ewm/'
knitr::opts_knit$set(root.dir = PROJECT_DIR)
options(java.parameters = "-Xmx4096m")
```

```{r load_packages}
library(dplyr)
library(testthat)
library(lubridate)
```

## GH_EW_01

```{r read_data}
df <- read.csv(file = paste(PROJECT_DIR,
                     "result_package_gh_ew_01_mls.csv",
                     sep=""),
               header = TRUE,
               sep = ",",
               dec = ",")
df <- tbl_df(df)
```

```{r column_name_fix_1}
colnames(df) <- gsub("X.BIC.",
                     "",
                     colnames(df))
```

```{r timestamp_conversion_1}
colnames_to_ymd_convert <- grep("GEWTSTP",
                                colnames(df),
                                value = TRUE)
df <-df %>%
  mutate_each_(funs(ymd_hms),
               vars = colnames_to_ymd_convert)
# There will be warnings, since empty values cannot
# be parsed. Those will become NAs, which is ok.
```

Checking which stat and tstp columns have their respective counterparts in gewtstp gewstat respectively.

```{r tstp_stat_checks}
colnames_gewstat_check <- grep("GEWSTAT",
                               colnames(df),
                               value = TRUE)
colnames_gewtstp_check <- grep("GEWTSTP",
                                colnames(df),
                                value = TRUE)
check_if_contained <- function(source, target_list) {
  # Comparing the numbers
  checker_list <- grepl(substr(source, 8, 10),
                        target_list)
  return(any(checker_list))
}
check_in_gewstat <- function(source) {
  return(check_if_contained(source,
                            colnames_gewstat_check))
}
check_in_gewtstp <- function(source) {
  return(check_if_contained(source,
                            colnames_gewtstp_check))
}
gewstats_in_gewtstp <- unlist(lapply(X = colnames_gewstat_check,
                                     FUN = check_in_gewtstp))
gewtstps_in_gewstat <- unlist(lapply(X = colnames_gewtstp_check,
                                     FUN = check_in_gewstat))
colnames_gewstat_check <- colnames_gewstat_check[gewstats_in_gewtstp]
colnames_gewtstp_check <- colnames_gewtstp_check[gewtstps_in_gewstat]
```

Checking that if there are values in the stat columns then the time stamps are not empty.

```{r tstp_stat_content_check}

stat_tstp_checker <- function(df, stat, tstp) {
  # If there is a stat value but NA in the timestamp field,
  # then it is a wrong row.
  wrong_rows_df <- df %>%
    filter_(as.formula(paste("~!is.na(",
                             as.name(stat),
                             ") & is.na(",
                             as.name(tstp),
                             ")",
                             sep = "")))
      # !is.na(as.name(stat)) & is.na(as.name(tstp)))
  return(wrong_rows_df)
}

for(i in 1:length(colnames_gewtstp_check)) {
  wrong_rows_df <- stat_tstp_checker(df,
                        colnames_gewstat_check[i],
                        colnames_gewtstp_check[i])
  test_that(desc = paste(i,
                         " - ",
                         colnames_gewtstp_check[i],
                         paste = ""),
            code = {expect_equal(object = nrow(wrong_rows_df),
                                     expected = 0)
    })
}
# If there are no errors all is good.
```

```{r LE_checks}
le_tester <- function(df, later_tstp, earlier_tstp) {
  later_tstp_name <- as.name(paste("GEWTSTP",
                           later_tstp,
                           sep = ""))
  earlier_tstp_name <- as.name(paste("GEWTSTP",
                             earlier_tstp,
                             sep = ""))
  result_name_abap <- as.name(paste("GEW",
                       earlier_tstp,
                       later_tstp,
                       "L",
                       sep = ""))
  result_name_r <- paste(earlier_tstp,
                         later_tstp,
                         "L",
                         sep = "")
  a <- df %>%
    mutate_(result = as.formula(paste("~time_length((",
                           later_tstp_name,
                           "-",
                           earlier_tstp_name,
                           "), 'seconds') - ",
                           result_name_abap,
                           sep = ""))) %>%
    # Translates into:
    # mutate(result = time_length(("GEWTSTP30" - "GEWTSTP20"),
    #                          "seconds") - "GEW2030L") %>%
    filter(abs(result) > 0.01)
    # Minor differences may occur due to calculations and time_length
    # returning numeric and not integer, this is only a number
    # arithmetic phenomenon and not an error.
  if (nrow(a) != 0) {
    browser()
  } else {
    test_that(desc = result_name_r, code = {
                        expect_equal(object = nrow(a),
                                     expected = 0)
    })
  }
}
le_tester(df = dfx,
          later_tstp = 30,
          earlier_tstp = 20)
le_tester(df = dfx,
          later_tstp = 40,
          earlier_tstp = 30)
le_tester(df = dfx,
          later_tstp = 75,
          earlier_tstp = 65)
le_tester(df = dfx,
          later_tstp = 80,
          earlier_tstp = 70)
le_tester(df = dfx,
          later_tstp = 90,
          earlier_tstp = 80)
le_tester(df = dfx,
          later_tstp = 80,
          earlier_tstp = 20)
```

In case of TE calculations if min is to be calculated but there are NAs present in the records, then the minimum will not be calculated. If the minimum is not calculated, then the difference is also NA. Comparing 0s from SAP and NAs from R (0 - NA) will result in NAs and those are not selected by the dplyr filter statement.

Keep only the values where we have a TE

```{r}
dfx <- df %>% 
  filter(!is.na(G0WM_TU_N)) %>%
  arrange(G0WM_TU_N)
```

```{r TE_checks}
te_calcs <- dfx %>%
  group_by(G0WM_TU_N) %>%
  summarise(minGEWTSTP40 = min(GEWTSTP40),
            maxGEWTSTP45 = max(GEWTSTP45),
            avgGEWTSTP45 = mean(GEWTSTP45),
            minGEWTSTP65 = min(GEWTSTP65),
            maxGEWTSTP65 = max(GEWTSTP65),
            minGEWTSTP75 = min(GEWTSTP75),
            maxGEWTSTP75 = max(GEWTSTP75)) %>%
  mutate(calc4045T = maxGEWTSTP45 - minGEWTSTP40,
         calc6565T = maxGEWTSTP65 - minGEWTSTP65,
         calc7575T = maxGEWTSTP75 - minGEWTSTP75)
dfx <- left_join(dfx, te_calcs,
                 by = "G0WM_TU_N")

te_tester <- function(df, later_tstp, earlier_tstp) {
  calc_tstp_name <- as.name(paste("calc",
                           earlier_tstp,
                           later_tstp,
                           "T",
                           sep = ""))
  result_name_abap <- as.name(paste("GEW",
                       earlier_tstp,
                       later_tstp,
                       "T",
                       sep = ""))
  result_name_r <- paste(earlier_tstp,
                         later_tstp,
                         "T",
                         sep = "")
  a <- dfx %>%
    mutate_(result = as.formula(paste("~",
                                      calc_tstp_name,
                                      "-",
                                      result_name_abap,
                                      sep = ""))) %>%
    filter(abs(result) > 0.01)
  test_that(desc = calc_tstp_name, code = {
    expect_equal(object = nrow(a),
                 expected = 0)
  })
}

te_tester(df = dfx,
          later_tstp = 45,
          earlier_tstp = 40)
te_tester(df = dfx,
          later_tstp = 65,
          earlier_tstp = 65)
te_tester(df = dfx,
          later_tstp = 75,
          earlier_tstp = 75)
```


```{r export}
write.csv(x = dfx,
          file = "dfx.csv")
```

## GH_EW_B02

```{r read_data2}
source_df <- read.csv(file = paste(PROJECT_DIR,
                     "source_package_gh_ew_b02.csv",
                     sep=""),
               header = TRUE,
               sep = ",",
               dec = ",")
source_df <- tbl_df(source_df)
result_df <- read.csv(file = paste(PROJECT_DIR,
                     "result_package_gh_ew_b02.csv",
                     sep=""),
               header = TRUE,
               sep = ",",
               dec = ",")
result_df <- tbl_df(result_df)
in_out_df <- read.csv(file = paste(PROJECT_DIR,
                     "records_in_out_gh_ew_b02.csv",
                     sep=""),
               header = TRUE,
               sep = ",",
               dec = ",")
in_out_df <- tbl_df(in_out_df)
bic_pgewkpi <- read.csv(file = paste(PROJECT_DIR,
                       "bic_pgewkpi.csv",
                       sep=""),
               header = TRUE,
               sep = ",",
               dec = ",",
               stringsAsFactors = FALSE)
bic_pgewkpi <- tbl_df(bic_pgewkpi)
```

```{r column_name_fix_2}
colnames(source_df) <- gsub("X.BIC.",
                            "",
                            colnames(source_df))
colnames(result_df) <- gsub("X.BIC.",
                            "",
                            colnames(result_df))
colnames(bic_pgewkpi) <- gsub("X.BIC.",
                              "",
                              colnames(bic_pgewkpi))
```

```{r timestamp_conversion_2}
colnames_to_ymd_convert <- grep("GEWTSTP",
                                colnames(source_df),
                                value = TRUE)
source_df <- source_df %>%
  mutate_each_(funs(ymd_hms),
               vars = colnames_to_ymd_convert)
# There will be warnings, since empty values cannot
# be parsed. Those will become NAs, which is ok.
```

## Check that relevant KPIs are generated.

```{r result_row_fetcher}
get_result_rows <- function(source_rows) {
  in_out_rows <- in_out_df %>%
    filter(INRECORD %in% source_rows$INDEX)

  result_rows <- result_df %>%
    filter(INDEX %in% in_out_rows$OUTRECORD)
  
  return(result_rows)
}
```

Checking that the mapping via TE (G0WM_TU_N) is the same as the mapping via in_out values of the transformation logger. **This way the logger can be checked to be working well.** There might be some records which do not have a TE yet, these have to be filtered out from the check, these are in the state before they could have received that state.

```{r checking_in_out_mapping_via_TE}
source_rows <- source_df %>%
  filter(!is.na(G0WM_TU_N))

result_rows_via_mapping <- get_result_rows(source_rows)

result_rows_via_g0wm_tu_n <- result_df %>%
  filter(G0WM_TU_N %in% source_rows$G0WM_TU_N)

test_that(desc = "G0WM_TU_N mapping is the same as the logger mapping",
          code = {
            expect_true(nrow(result_rows_via_mapping) ==
                        nrow(result_rows_via_g0wm_tu_n))
          })
rm("source_rows",
   "result_rows",
   "result_rows_via_mapping",
   "result_rows_via_g0wm_tu_n")
```

KPI3 has to be generated only, as tstp20 and tstp30 are the only present values. This is the case for rows where there is not LE given (no G0WM_TU_N). The identification is therefore possible only via in-out mapping of the transformation logger. In such a case only one record should be found in the result row, that is to be checked as well.

```{r single_kpi}
source_rows <- source_df %>%
  filter(!is.na(GEWTSTP20) &
        !is.na(GEWTSTP30) &
        is.na(GEWSTAT40))

result_rows <- get_result_rows(source_rows)

test_that(desc = "Only one result is created for records with max GEWTSTP30",
          code = {
            expect_true(nrow(source_rows) == nrow(result_rows))
          })

test_that(desc = "Only KPI3 got generated and nothing else for records with max GEWTSTP30",
          code = {
            expect_true(all(result_rows$GEWKPI == "KPI3"))
          })
rm("source_rows",
   "result_rows")
```

Checking that if KPI4 is present then KPI3 is present as well. Besides checking that if KPI4 is present then TE (G0WM_TU_N) is not empty.

```{r KPI3_KPI4}
source_rows <- source_df %>%
  filter(!is.na(GEWTSTP40))

result_rows <- get_result_rows(source_rows)

test_that(desc = "KPI3 is present if KPI4 exists",
          code = {
            a <- result_rows %>%
              filter(GEWKPI == "KPI3")
            b <- result_rows %>%
              filter(GEWKPI == "KPI4")
            expect_true(nrow(a) == nrow(b))
          })

test_that(desc = "TE (G0WM_TU_N) is not empty if KPI4 is present",
          code = {
            a <- result_rows %>%
              filter(GEWKPI == "KPI4" &
                    is.na(G0WM_TU_N))
            expect_true(nrow(a) == 0)
          })

rm("source_rows",
   "result_rows")
```

Check that exactly the necessary amount of KPIs got generated globally.

```{r KPI_number_check}
count_non_zero <- function(colname) {
  return(sum(source_df[colname] != 0))
}

to_become_KPI_columns <- grep(pattern = "^GEW[0-9]{4}[LT]$",
                              x = colnames(source_df),
                              value = TRUE)
KPIs_to_be_generated <- unlist(lapply(X = to_become_KPI_columns,
       FUN = count_non_zero))

kpi_gen <- as.data.frame(to_become_KPI_columns,
                         stringsAsFactors = FALSE)
kpi_gen <- cbind(kpi_gen, KPIs_to_be_generated)

bic_pgewkpi <- bic_pgewkpi %>%
  mutate(to_become_KPI_columns = ifelse(GEWKPITYP == "LE" |
                                        GEWKPITYP == "TE",
                                        yes = paste("GEW",
                                                     substr(bic_pgewkpi$GEWVONST, 13, 14),
                                                     substr(bic_pgewkpi$GEWBISST, 13, 14),
                                                     substr(bic_pgewkpi$GEWKPITYP, 1, 1),
                                                     sep = ""),
                                        no = NA)) %>%
  filter(OBJVERS == "A" & GEWKPI != "")
kpi_gen <- left_join(x = kpi_gen,
                     y = bic_pgewkpi,
                     by = "to_become_KPI_columns")

# Adding special case GEWSTAT65, KPI51
source_rows <- source_df %>%
  filter(!is.na(GEWSTAT65))

kpi_gen <- rbind(kpi_gen,
                 c("", nrow(source_rows), "KPI51",
                   "", "", "", "", ""))

kpi_gen$KPIs_to_be_generated = as.numeric(kpi_gen$KPIs_to_be_generated)

test_that(desc = paste("The number of KPIs to be generated equals",
                       "to the number of rows in the result package",
                       sep = ""),
          code = {
            expect_true(sum(kpi_gen$KPIs_to_be_generated) ==
                        nrow(result_df))
          })
```

Check that the necessary amount has been generated per KPI.

```{r KPI_number_check_2}
count_KPI <- function(KPI) {
  a <- result_df %>%
   filter(GEWKPI == KPI)
  return(nrow(a))
}

a <- unlist(lapply(X = kpi_gen$GEWKPI,
            FUN = count_KPI))

kpi_gen <- kpi_gen %>%
  mutate(KPIs_actually_generated = a)

test_that(desc = "KPI generation numbers per KPI matches with expectations",
          code = {
            expect_equal(object = kpi_gen$KPIs_actually_generated,
                         expected =  kpi_gen$KPIs_to_be_generated)
          })
rm("a")
```